---
author: 
  - Derick Baum, Harvard University
  - Xiang Zhou, Harvard University
title: "`rbw`: An `R` package for Constructing Residual Balancing Weights"
date: "September 22, 2021"
abstract: >
  We describe the `R` package `rbw`, which implements the method of residual balancing weights (RBW) for estimating marginal structural models. In contrast to other methods such as inverse probability weighting (IPW) and covariate balancing propensity scores (CBPS), RBW involves modeling the conditional means of post-treatment confounders instead of the conditional distributions of the treatment to construct the weights. RBW is thus easier to use with continuous treatments, and the method is less susceptible to model misspecification issues that often arise when modeling the conditional distributions of treatments. RBW is also advantageous from a computational perspective. Because its weighting procedure involves a convex optimization problem, RBW typically locates a solution considerably faster than other methods whose optimization relies on nonconvex loss functions — such as the recently proposed nonparametric version of CBPS. We explain the rationale behind RBW, describe the functions in `rbw`, and then use real-world data to illustrate their applications in three scenarios: effect estimation for point treatments, causal mediation analysis, and effect estimation for time-varying treatments with time-varying confounders. 
header-includes:
- \usepackage{color}
- \usepackage{tikz}
- \usepackage{pgfplots}
- \usetikzlibrary{arrows.meta}
- \usepackage{caption}
- \usepackage{amsfonts}
- \usepackage{hyperref}
- \usepackage{float}
- \usepackage{amsmath}
- \usepackage{bm}
- \usepackage{booktabs}
- \usepackage{makecell}
- \hypersetup{
    colorlinks=true,
    linkcolor=blue,
    }
- \newcommand{\indep}{\perp \!\!\! \perp}
output: 
  pdf_document:
    number_sections: true
vignette: >
  %\VignetteIndexEntry{`rbw`: An `R` package for Constructing Residual Balancing Weights}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
bibliography: RBW.bib
urlcolor: blue
---

# Introduction {short-title="Introduction" #intro}

This paper describes the `R` package `rbw`, which implements the method of residual balancing weights for estimating marginal structural models (MSMs) [@zhouResidualBalancingMethod2020a]. MSMs seek to estimate causal effects in the presence of post-treatment confounding — a common issue in the social sciences. In studies of time-varying treatments, prior treatments may affect the confounders of future treatments. For example, research has shown that political candidates' decision to run negative advertisements is determined by their position in recent polling data, which are in turn affected by their previous decisions to run negative advertisements [@lauEffectsNegativePolitical2007; @blackwellFrameworkDynamicCausal2013]. Post-treatment confounding can also occur in causal mediation analysis when confounders of the mediator-outcome relationship are affected by the treatment. For example, such a problem arises in 
a study of the mediating role of morality in the effect of shared democracy on public support for war [@tomzPublicOpinionDemocratic2013a]. Post-treatment variables, such as respondents' beliefs about the likelihood of victory, may determine both perceptions of morality and support for military intervention.

MSMs aim to address two types of bias associated with conventional regression methods that adjust naively for post-treatment confounders: overcontrol and collider-stratification bias [@robinsNewApproachCausal1986; -@robinsMarginalStructuralModels2000a]. Conditioning naively on post-treatment confounders can create overcontrol bias as it blocks the effect of the treatment on the outcome that passes through these variables. Additionally, conditioning naively on post-treatment confounders can lead to collider-stratification bias when these variables are affected by unobserved determinants of the outcome. This is because the adjustment will create a spurious association between the treatment and the unobserved variables. 

Researchers often use inverse probability weighting (IPW) to fit MSMs [for an in-depth explanation of the method, see @robinsMarginalStructuralModels2000; @robinsMarginalStructuralModels2000a; @coleConstructingInverseProbability2008a]. In longitudinal settings, MSMs with IPW involve fitting a model for the conditional mean of the outcome given the treatment history using weights that break the dependence between past confounders and the treatment at each time point. In essence, the weights create a pseudo-population where the marginal mean of the potential outcomes under a treatment history equals the conditional mean of the observed outcome given the treatment history. The `R` package `ipw` provides functions for estimating inverse probability weights [@vanderwalIpwPackageInverse2011; @R-ipw]. 

However, IPW's success depends on correct specification of the models for the conditional distributions of exposure to treatment and/or mediator (hereafter jointly referred to as "exposures"), which is difficult to achieve in practice. Moreover, even when these models are correctly specified, IPW is inefficient and susceptible to finite-sample bias [@zhouResidualBalancingMethod2020a; @wangDiagnosingBiasInverse2006]. Finally, when the exposures are continuous, IPW may perform poorly due to unreliable estimation of conditional densities [@naimiConstructingInverseProbability2014; @vansteelandtEstimatingDirectEffects2009].

Alternative methods have attempted to mitigate these shortcomings. In particular, Imai and Ratkovic's [-@imaiCovariateBalancingPropensity2014; -@imaiRobustEstimationInverse2015] covariate balancing propensity score (CBPS) method proposes a set of balancing conditions when estimating the propensity scores. Because it seeks to maximize the covariate balance between the treatment and control groups, this method is less sensitive to model misspecification than IPW. @fongCovariateBalancingPropensity2018 expand CBPS to accommodate continuous exposures, but the challenges involved in modeling conditional densities persist. With this in mind, they have also developed a nonparametric extension that constructs weights that maximize the empirical likelihood while meeting a set of balancing conditions. Though the nonparametric CBPS (npCBPS) circumvents the need for specifying a functional form for the propensity score, it does so at a cost — since the empirical likelihood is not generally convex, the optimization procedure is often slow and may fail to find a solution. The latter can happen, for example, when we have a large number of covariates. The authors advance a workaround that adds flexibility to the covariate balancing conditions and penalizes the remaining imbalance. In doing so, they ensure that a weighting solution exists. Users can implement CBPS in `R` with the `CBPS` package [@R-CBPS].

Recently, @zhouResidualBalancingMethod2020a propose the method of residual balancing weights (RBW) for estimating MSMs. RBW involves fitting models for the conditional means of post-treatment confounders given past treatments and confounders and extracting their residual terms. It then uses Hainmueller's [-@hainmuellerEntropyBalancingCausal2012] entropy balancing method to find weights such that, in the weighted sample, 1) the residuals are orthogonal to future exposures, past treatments, and past confounders, and 2) the relative entropy between the weights and a set of base weights (e.g., survey sampling weights) is minimized. RBW is similar to npCBPS in that it relies on a set of balancing conditions to find the weights and does not require modeling the conditional distributions of the exposures. Both methods can, therefore, be easily adapted to cases where exposures are continuous. Despite their similarities, RBW has a significant computational advantage: the relative entropy metric it uses to construct the weights leads to a convex optimization problem, so finding the weighting solution is computationally expeditious. As shown below, RBW manages to locate the solution considerably faster than npCBPS when we compare the methods' performance for the same problem. 

In the sections that follow, we present an overview of the residual balancing method (Section \ref{residual-balancing}) and how, in addition to contexts involving time-varying treatments, we can use it in cases of point treatments and causal mediation analysis (Section \ref{uses}). We then discuss the package that implements the method in `R` (`rbw`). Section \ref{r-package} describes the functions included in `rbw`, and Section \ref{examples} illustrates their use with various data sets. Section \ref{conclusion} concludes. 

# Overview of Residual Balancing {short-title="Residual Balancing" #residual-balancing}

This section gives an overview of RBW [see @zhouResidualBalancingMethod2020a for a thorough exposition of the method]. We first describe the notation used throughout the paper and briefly review MSMs. Next, we explain the underlying logic of RBW and provide an intuition for how the method works using a directed acyclic graph (DAG).

## Notation

Assume we have a study with $T\ge2$ time points, and we are interested in the effect of a time-varying treatment, $A_{t}$ ($1\le t \le T$), on some end-of-study outcome $Y$. We also have a vector of observed time-varying confounders, $L_{t}$, at each time point, which may be affected by prior treatments. $\bar{A}_{t}=(A_{1},...,A_{t})$ and $\bar{L}_{t}=(L_{1},...,L_{t})$ denote treatment and covariate histories up to time $t$. Furthermore, $\bar{A}=\bar{A}_{T}$ and $\bar{L}=\bar{L}_{T}$ represent a respondent's complete treatment and covariate histories, respectively. Finally, let $Y(\bar{a})$ be the potential outcome under some treatment history $\bar{a}$.

## MSMs 

An MSM is a model for the marginal mean of the potential outcomes under some treatment history:

\begin{equation}
\label{eq:1}
\mathbb{E}[Y(\bar{a})]=\mu(\bar{a};\beta),
\end{equation}

where $\mu(.)$ is some function and $\beta$ are a set of parameters capturing the causal effects of interest. We can identify an MSM from observed data under three assumptions:

1. consistency: if $\bar{A}=\bar{a}$, then $Y=Y(\bar{a})$;
2. sequential ignorability: at each time point $t$, treatment is unconfounded conditional on past treatments and the covariate history up to that point. Formally, $Y(\bar{a})\indep A_{t}|\bar{A}_{t-1},\bar{L}_{t}$; and
3. positivity: at each time point $t$, treatment assignment must not be deterministic. That is, if $f(\bar{A}_{t-1}=\bar{a}_{t-1}, \bar{L}_{t}=\bar{l}_{t})>0$, then $f(A_{t}=a_{t}|\bar{A}_{t-1}=\bar{a}_{t-1}, \bar{L}_{t}=\bar{l}_{t})>0$, where $f(\cdot)$ represents a probability mass or density function.

Under these assumptions, @robinsNewApproachCausal1986 shows that the expected value of the potential outcome $\mathbb{E}[Y(\bar{a})]$ can be identified via the g-computation formula:

\begin{equation}
\label{eq:2}
\mathbb{E}[Y(\bar{a})]=\int...\int\mathbb{E}[Y|\bar{A}=\bar{a}, \bar{L}=\bar{l}]\prod^{T}_{t=1}f(l_{t}|\bar{l}_{t-1},\bar{a}_{t-1})d\mu(l_{t}),
\end{equation}

where $\mu()$ is an appropriate dominating measure.  While Equation \ref{eq:2} provides a general formula for identifying causal effects in the presence of time-varying treatments, directly evaluating it is often impractical, particularly when we have many covariates and time periods. 

## The Rationale Behind Residual Balancing {short-title="RBW Panel" #rbw-panel}

Now consider the formula for the conditional mean of the observed outcome $Y$ given some treatment history:

\begin{equation}
\label{eq:3}
\mathbb{E}[Y|\bar{A}=\bar{a}]=\int...\int\mathbb{E}[Y|\bar{A}=\bar{a}, \bar{L}=\bar{l}]\prod^{T}_{t=1}f(l_{t}|\bar{l}_{t-1},\bar{a})d\mu(l_{t}).
\end{equation}

By comparing Equations \ref{eq:2} and \ref{eq:3}, we see that weighting the observed population by 

\begin{equation}
\label{eq:4}
W_{l}=\prod^{T}_{t=1}\frac{f(L_{t}|\bar{L}_{t-1},\bar{A}_{t-1})}{f(L_{t}|\bar{L}_{t-1},\bar{A})}
\end{equation}

creates a pseudo-population in which $f^{*}(l_{t}|\bar{l}_{t-1},\bar{a})=f^{*}(l_{t}|\bar{l}_{t-1},\bar{a}_{t-1})=f(l_{t}|\bar{l}_{t-1},\bar{a}_{t-1})$ and $\mathbb{E}^{*}[Y|\bar{A}=\bar{a}]=\mathbb{E}^{*}[Y(\bar{a})]=\mathbb{E}[Y(\bar{a})]$, where * represents quantities in the pseudo-population. Estimating the conditional densities of Equation \ref{eq:4} is challenging because $L_{t}$ is often high-dimensional. 

\sloppy @zhouResidualBalancingMethod2020a demonstrate that the condition $f^{*}(l_{t}|\bar{l}_{t-1},\bar{a})=f^{*}(l_{t}|\bar{l}_{t-1},\bar{a}_{t-1})=f(l_{t}|\bar{l}_{t-1},\bar{a}_{t-1})$ implies a series of moment conditions in the pseudo-population. Most importantly, 

\begin{equation}
\label{eq:5}
\mathbb{E}^{*}[\delta(g(L_{t}))h(\bar{L}_{t-1},\bar{A})]=\mathbb{E}^{*}[\delta(g(L_{t}))]\mathbb{E}^{*}[h(\bar{L}_{t-1},\bar{A})]=0,
\end{equation}

where:

* $g(.)$ and $h(.)$ are scalar functions.
* $\delta(g(L_{t}))$ is the residual of $g(L_{t})$ with respect to its conditional mean given the observed past: $\delta(g(L_{t}))=g(L_{t})-\mathbb{E}[g(L_{t})|\bar{L}_{t-1},\bar{A}_{t-1}]$.

Residual balancing aims to emulate the moment conditions (\ref{eq:5}) that would hold in the pseudo-population if it were possible to weight the observed population by $W_{l}$. To do so, the method 1) specifies a set of $g(\cdot)$ functions, $G(L_{t})=\{g_{1}(L_{t}),...,g_{J_{t}}(L_{t})\}$ and a set of $h(.)$ functions, $H(\bar{L}_{t-1},\bar{A})=\{h_{1}(\bar{L}_{t-1},\bar{A}),...,h_{K_{t}}(\bar{L}_{t-1},\bar{A})\}$; 2) computes a set of residual terms $\delta(g(L_{t}))=g(L_{t})-\mathbb{E}[g(L_{t})|\bar{L}_{t-1},\bar{A}_{t-1}]$; and 3) finds a set of weights such that, for any $j$, $k$, and $t$, the cross-moment of $\delta(g_{j}(l_{it}))$ and $h_{k}(\bar{l}_{i,t-1},\bar{a}_{i})$ is zero in the weighted data. That is, RBW locates the $rbw_{i}$ weights subject to the following balancing conditions:

\begin{equation}
\label{eq:6}
\sum^{n}_{i=1}rbw_{i}c_{ir}=0, \,\,\, 1 \le r \le n_{c},
\end{equation}

where $c_{ir}$ is the rth element of $\boldsymbol{c}_{i}=\{\delta(g_{j}(l_{it}))h_{k}(\bar{l}_{i,t-1},\bar{a}_{i}); 1 \le j \le J_{t}, 1 \le k \le K_{t}, 1 \le t \le T\}$ and $n_{c}=\sum^{T}_{t=1}J_{t}K_{t}$ denotes the total number of balancing conditions. The residualized confounders at each time point are balanced across future treatments as well as past treatments and confounders (the observed past). RBW thus adjusts for post-treatment confounding without inducing overcontrol and collider-stratification bias. 

Moreover, @zhouResidualBalancingMethod2020a follow @hainmuellerEntropyBalancingCausal2012 and minimize the relative entropy between $rbw_{i}$ and a set of base weights $q_{i}$ (e.g., survey sampling weights):

\begin{equation}
\label{eq:7}
\min_{rbw_{i}}\sum_{i}rbw_{i}\log (rbw_{i}/q_{i})
\end{equation}

We can then use the method of Lagrange multipliers to find a weighting solution that minimizes the relative entropy between $rbw_{i}$ and $q_{i}$ subject to the $n_{c}$ balancing constraints. We discuss this procedure in greater depth in Section \ref{eb2} when describing the function `rbw::eb2()`. The convexity of the relative entropy metric renders it considerably more computationally efficient than nonconvex loss functions that can also be used to construct weights, such as the empirical likelihood [@fongCovariateBalancingPropensity2018]. 

A typical implementation of residual balancing can be summarized in three steps:

1. For each covariate $j$ and at each time point $t$, fit a linear, logistic, or Poisson regression of $l_{ijt}$ (depending on its level of measurement) on $\bar{l}_{i,t-1}$ and $\bar{a}_{i,t-1}$. Then compute the residuals $\hat{\delta}(l_{ijt})$. For the covariates in $L_{1}$ (the first time period), the residuals are computed as deviations from the sample mean: $\hat{\delta}(l_{ij1})=l_{ij1}-\text{avg}(l_{j1})$. This step relies on the idea that $g_{j}(L_{t})=L_{jt}$, where $L_{jt}$ is the jth element of the covariate vector $L_{t}$, is a natural choice for the set of $g(.)$ functions constituting $G(L_{t})$.
2. Find a set of weights, $rbw_{i}$, such that:
    a) in the weighted sample, the residuals $\hat{\delta}(l_{ijt})$ are orthogonal to all future treatments and the regressors of $l_{ijt}$ (i.e., the past treatments and past confounders); 
    b) the relative entroy between $rbw_{i}$ and the base weights $q_{i}$ is minimized. 
3. Use the weights to fit an MSM. 

Figure \ref{fig:1} depicts the logic of RBW in a DAG. Following the notation described above, $A_{t}$ denotes our time-varying treatment, $L_{t}$ is a vector of time-varying confounders, and $Y$ is our end-of-study outcome. Further, assume two time points, $t=1,2$. The $rbw_{i}$ weights break the dependence between $A_{t}$ and $\bar{L}_{t}$ at each time point. That is, the weights create a pseudo-population where the confounding arrows $L_{1}\rightarrow A_{1}$, $L_{1}\rightarrow A_{2}$, and $L_{2}\rightarrow A_{2}$ are broken while all others are preserved. It is important to note that $L_{1}$ is *marginally* independent of both $A_{1}$ and $A_{2}$ in the pseudo-population, but $L_{2}$ is *conditionally* independent of $A_{2}$, given $L_{1}$ and $A_{1}$. Hence, RBW invokes a model for the conditional mean of $L_{2}$ given $L_{1}$ and $A_{1}$ and balances the residuals from this model across levels of $A_{2}$ and levels of $(L_{1}, A_{1})$ (the observed past). This procedure avoids overcontrol and collider-stratification bias when adjusting for post-treatment confounding because it breaks the confounding arrow $L_{2}\rightarrow A_{2}$ while leaving the causal arrow $A_{1}\rightarrow L_{2}$ intact. 

Finally, since $\mathbb{E}^{*}[Y|\bar{A}=\bar{a}]=\mathbb{E}^{*}[Y(\bar{a})]=\mathbb{E}[Y(\bar{a})]$ in the pseudo-population, we can estimate the marginal effects of interest by fitting a model for the conditional mean of the observed outcome given the treatment history (and possibly a set of baseline confounders) with weights equal to $rbw_{i}$.  

\begin{figure} [ht]
\begin{center}
\begin{tikzpicture}
% nodes %
\node (L1) at (0, 0) {\large $L_{1}$};
\node (L2) at (5, 0) {\large $L_{2}$};
\node (A1) at (0, -5) {\large $A_{1}$};
\node (A2) at (5, -5) {\large $A_{2}$};
\node (Y) at (10, -5) {\large $Y$};
\node[red] at (0, -2.5) {\large X};
\node[red] at (5, -2) {\large X};
\node[red] at (2, -2) {\large X};
% edges %
\draw [->, line width= 1.5] (L1) -- (L2);
\draw [->, red, loosely dashed, line width= 1.5] (L1) -- (A1);
\draw [->, red, loosely dashed, line width= 1.5] (L1) -- (A2);
\draw [->, red, loosely dashed, line width= 1.5] (L2) -- (A2);
\draw [->, line width= 1.5] (A1) -- (A2);
\draw [->, line width= 1.5] (A1) to[out=-45,in=-145] (Y);
\draw [->, line width= 1.5] (A1) -- (L2);
\draw [->, line width= 1.5] (L1) -- (Y);
\draw [->, line width= 1.5] (A2) -- (Y);
\draw [->, line width= 1.5] (L2) -- (Y);
\end{tikzpicture}
\end{center}
\caption{The underlying logic of residual balancing.}
\label{fig:1}
\end{figure}

# Uses of Residual Balancing {short-title="Uses" #uses}

The rationale described in the previous section is targeted at estimating the causal effects of time-varying treatments. With minor adaptations, we can expand the use of RBW to two other contexts commonly encountered in the social and biomedical sciences: point treatment situations and causal mediation analysis. 

## RBW for Estimating the Average Effect of a Point Treatment {short-title="RBW Treatment" #rbw-treatment}

RBW can be easily adapted to a point treatment situation where the user aims only to adjust for a set of baseline (i.e., time-invariant) confounders to estimate the average treatment effect. To this end, we modify the procedure above as follows: 

1. Compute the response residuals $\hat{\delta}(x_{ij})$ for each baseline confounder $X_{j}$ by centering it around its sample mean: $\hat{\delta}(x_{ij})=x_{ij}-\text{avg}({x}_{j})$.
2. Find a set of weights, $rbw_{i}$, such that:
    a) in the weighted sample, the residuals $\hat{\delta}(x_{ij})$ are orthogonal to the treatment;
    b) the relative entropy between $rbw_{i}$ and the base weights $q_{i}$ is minimized.
3. Use the weights to fit an MSM.

The DAG of Figure \ref{fig:2} illustrates the point treatment situation. $A$ represents the one-shot treatment, $X$ is a vector of baseline confounders, and $Y$ denotes our outcome. Weighting the observed population by $rbw_{i}$ mimics a pseudo-population where the link between $A$ and $X$ is broken. We can then fit a model for the conditional mean of $Y$ given $A$ to estimate the causal effects of interest.^[The vector $X$ captures all confounding under the ignorability assumption.]

\begin{figure} [ht]
\begin{center}
\begin{tikzpicture}
% nodes %
\node (A) at (0, 0) {\large $A$};
\node (Y) at (5, 0) {\large $Y$};
\node (X) at (0, 5) {\large $X$};
\node[red] at (0, 2.5) {\large X};
% edges %
\draw [->, line width= 1.5] (A) -- (Y);
\draw [->, red, loosely dashed, line width= 1.5] (X) -- (A);
\draw [->, line width= 1.5] (X) -- (Y);
\end{tikzpicture}
\end{center}
\caption{RBW in a Point Treatment.}
\label{fig:2}
\end{figure}

## RBW in Causal Mediation Analysis {short-title="RBW Mediation" #rbw-mediation}

In causal mediation analysis, researchers are often concerned with the joint effects of a one-shot treatment, $A$, and a mediator, $M$, on some end-of-study outcome $Y$ when both baseline confounders ($X$) and some post-treatment confounders for the mediator-outcome relationship ($Z$) are present. With minor adjustments, the RBW implementation for causal mediation analysis is similar to the case with time-varying treatments: 

1. As in the point treatment scenario, compute the response residuals $\hat{\delta}(x_{ij})$ for each baseline confounder $X_{j}$ by centering it around its sample mean.
    * Note: users may skip this step while including the baseline confounders in the MSM in the final step.
2. Estimate the response residuals $\hat{\delta}(z_{ij})$ for each post-treatment confounder $Z_{j}$ by fitting a linear, logistic, or Poisson regression of $z_{ij}$ (depending on its level of measurement) on the treatment $a_{i}$ and the baseline confounders $x_{i}$: $\hat{\delta}(z_{ij})=z_{ij}-\mathbb{E}[z_{ij}|a_{i},x_{i}]$.
3. Find a set of weights, $rbw_{i}$, such that:
    a) in the weighted sample, i) the baseline residuals $\hat{\delta}(x_{ij})$ are orthogonal to the treatment $a_{i}$ and the mediator $m_{i}$; and ii) the post-treatment residuals $\hat{\delta}(z_{ij})$ are balanced across the treatment $a_{i}$, the mediator $m_{i}$, and the baseline confounders $x_{i}$;
    b) the relative entropy between $rbw_{i}$ and the base weights $q_{i}$ is minimized.
4. Use the weights to fit an MSM for the joint effects of the treatment and the mediator on the outcome:
    a) In causal mediation analysis, the potential outcomes of interest are denoted by $Y(a,m)$ (this is the potential outcome under treatment $a$ and mediator value $m$). We can then express a saturated MSM as $\mathbb{E}[Y(a,m)]=\alpha_{0}+\alpha_{1}a+\alpha_{2}m+\alpha_{3}am$.
    b) Alternatively, the baseline confounders can be included in the MSM if users decide to skip the first step: $\mathbb{E}[Y(a,m)|X]=\alpha_{0}+\alpha_{1}a+\alpha_{2}m+\alpha_{3}am+\alpha_{4}^{T}X$.
    c) Finally, the controlled direct effects (CDE) of the treatment can be estimated as $\widehat{\text{CDE}}(m)=\mathbb{E}[Y(1,m)-Y(0,m)]=\hat{\alpha}_{1}+\hat{\alpha}_{3}m$. The CDE measures the causal effect of the treatment on the outcome when the mediator is fixed at some value $m$ for all units.

# The `R` package {short-title="R Package" #r-package}

The `R` package `ipw` contains four functions:

* `eb2()`, for generating minimum entropy weights subject to a set of balancing constraints.
* `rbwATE()`, for constructing residual balancing weights to estimate the causal effects of one-shot treatments. 
* `rbwMed()`, for constructing residual balancing weights to estimate controlled direct effects in causal mediation analysis.
* `rbwPanel()`, for constructing residual balancing weights to estimate the marginal effects of time-varying treatments.

Next, we explain each of these functions. The package also includes several real-world data sets (`advertisement`, `peace`, `campaign_long`, and `campaign_wide`), which we describe and analyze in the examples of Section \ref{examples}. 

## Function `eb2()` {short-title="eb2" #eb2}

This function is an adaptation of `ebal::eb()` [@R-ebal]. It is called internally by other functions in `rbw` to implement the method of Lagrange multipliers for locating a weighting solution that minimizes the relative entropy between $rbw_{i}$ and $q_{i}$ subject to the set of $n_{c}$ balancing constraints described in Equation \ref{eq:6}. @zhouResidualBalancingMethod2020a impose an additional normalization constraint that ensures that the residual balancing weights sum to the sample size: $\sum_{i}rbw_{i}=n$. Following @hainmuellerEntropyBalancingCausal2012, the authors obtain the primal optimization problem:

\begin{equation}
\label{eq:8}
\min_{rbw_{i}}L^{p}=\sum^{n}_{i=1}rbw_{i}\log (rbw_{i}/q_{i})+\sum^{n_{c}}_{r=1}\lambda_{r}\sum^{n}_{i=1}rbw_{i}c_{ir}+\lambda_{0}\bigg(\sum^{n}_{i=1}rbw_{i}-n\bigg),
\end{equation}

where $\{\lambda_{1},...,\lambda_{n_{c}}\}$ are the Lagrange multipliers for the balancing constraints and $\lambda_{0}$ is the Lagrange multiplier for the normalization constraint. Since the loss function $L^{p}$ is strictly convex, the first order condition of $\frac{\partial L^{p}}{\partial rbw_{i}}=0$ implies that the solution for each weight is

\begin{equation}
\label{eq:9}
rbw_{i}^{*}=\frac{nq_{i}\text{exp}(-\sum^{n_{c}}_{r=1}\lambda_{r}c_{ir})}{\sum^{n}_{i=1}q_{i}\text{exp}(-\sum^{n_{c}}_{r=1}\lambda_{r}c_{ir})}. 
\end{equation}

We can then insert Equation \ref{eq:9} into $L^{p}$, leading to an unrestricted dual problem:

\begin{equation}
\label{eq:10}
\max_{\lambda_{r}}L^{d}=-\log \bigg(\sum^{n}_{i=1}q_{i}\text{exp}(-\sum^{n_{c}}_{r=1}\lambda_{r}c_{ir})\bigg),
\end{equation}

or equivalently, 

\begin{equation}
\label{eq:11}
\min_{Z}L^{d}=\log \bigg(Q'\text{exp}(CZ)\bigg),
\end{equation}

where $Q=[q_{1},...,q_{n}]'$, $C=[\boldsymbol{c}_{1},...,\boldsymbol{c}_{1}]'$, and $Z=-[\lambda_{1},...,\lambda_{n_{c}}]'$. Since $L^{d}$ is strictly convex, the solution is guaranteed to be unique — assuming one exists. Given that both the gradient and the Hessian have closed-form expressions, we can solve the problem using Newton's method. `eb2()` implements the algorithm. If convergence is successful, the function tells the user that "Entropy minimization converged within tolerance level." Otherwise, it warns that entropy minimization did not converge and suggests increasing the number of iterations or reducing the number of balancing constraints. 

The convexity of our optimization problem leads to appreciable computational gains over other methods that use alternative loss functions. This will be demonstrated in Section \ref{point-treatment-example}, when we compare the performance of RBW with that of npCBPS, which uses the empirical likelihood, for the same problem. 

`eb2()` is used as: 

| `eb2(C, M, Q, Z = rep(0, ncol(C)), max_iter = 200, tol = 1e-04,`
|       `print_level = 2)`

and takes the following arguments:

* `C` is a constraint matrix, with each column representing a balancing constraint. 
* `M` is a vector of moment conditions to be met in the reweighted sample (per Equation \ref{eq:6}, this is a vector of zeros with length equal to the number of columns of `C` when the other functions in `rbw` call `eb2()` internally).
* `Q` is a vector of base weights.
* `Z` is a vector of Lagrange multipliers to be initialized.
* `max_iter` determines the maximum number of iterations for the Newton's method.
* `tol` is a tolerance parameter used to determine the convergence of the Newton's method. 
* `print_level` determines the level of printing: 
    * **1** normal: print whether the algorithm converges or not
    * **2** detailed: print also the maximum absolute value of the deviation between the moments of the reweighted data and the target moments in each iteration
    * **3** very detailed: print also the step length of the line searcher in iterations where a full Newton step is excessive

The output returned by `eb2()` is a list containing the following elements:

* `W` is a vector of normalized minimum entropy weights.
* `Z` is a vector of Lagrange multipliers.
* `converged` is a logical indicator for convergence. 
* `maxdiff` is a scalar indicating the maximum absolute value of the deviation between the moments of the reweighted data and the target moments in each iteration.

## Function `rbwATE()` {short-title="rbwATE" #rbwATE}

This function produces residual balancing weights to be used in a point treatment situation. It implements the steps described in Section \ref{rbw-treatment}. It first takes a set of baseline confounders and computes the response residuals for each confounder by centering it around its sample mean. Then it calls `eb2()` to find a set of weights, $rbw_{i}$, such that 1) the baseline residuals are orthogonal to the treatment in the weighted sample, and 2) the relative entropy between ${rbw}_{i}$ and the base weights is minimized. Additionally, `rbwATE()` calls a function that ensures that the matrix of balancing constraints comprises only linearly independent columns.

`rbwATE()` is used as:

| `rbwATE(treatment, data, baseline_x, base_weights, max_iter = 200,`
|            `print_level = 1, tol = 1e-6)`

and takes the following arguments:

* `max_iter`, `print_level`, and `tol` have the same definitions as in `eb2()`.
* `treatment` is a symbol or character string for the treatment variable.
* `data` is a data frame containing all variables in the model.
* `baseline_x` is an expression for a set of baseline confounders stored in `data`.
* `base_weights` is an *optional* vector of base weights (or its name). If no value is supplied, the function sets a vectors of ones with length equal to the sample size as the base weights.

The output returned by `rbwATE()` is a list containing the following elements:

* `weights` is a vector of residual balancing weights.
* `constraints` is a matrix of linearly independent residual balancing constraints.
* `eb_out` contains the results from calling the `eb2()` function. 
* `call` is the matched call (the function call with all arguments specified by their full names).

## Function `rbwMed()` {short-title="rbwMed" #rbwMed}

This function produces residual balancing weights for causal mediation analysis. It implements the steps described in Section \ref{rbw-mediation} by taking an *optional* set of baseline confounders (as explained above, users can opt instead to include these covariates in the MSM later) and a list of model objects for the conditional mean of the each post-treatment confounder given the treatment and the baseline confounders. It then calls `eb2()` to find a set of weights, $rbw_{i}$, such that, in the weighted sample, 1) the baseline residuals are orthogonal to the treatment and the mediator; 2) the post-treatment confounders are balanced across the treatment, the mediator, and the baseline confounders; and 3) the relative entropy between $rbw_{i}$ and the base weights is minimized.

`rbwMed()` takes an additional argument, `interact`, a logical variable indicating whether the baseline and post-treatment confounders should be balanced against the treatment-mediator interaction. This argument is set to `FALSE` by default, but users suspecting an interaction effect may find it prudent to balance against it. Like `rbwATE()`, `rbwMed()` calls a function internally to ensure that only linearly independent columns constitute the matrix of balancing constraints. 

It is used as: 

| `rbwMed(treatment, mediator, zmodels, data, baseline_x, interact = FALSE,`
|            `base_weights, max_iter = 200, print_level = 1, tol = 1e-04)`

and takes the following arguments:

* `treatment`, `data`, `base_weights`, `max_iter`, `print_level`, and `tol` are defined as in `rbwATE()`.
* `baseline_x` is an *optional* expression for a set of baseline confounders stored in `data`.
* `mediator` is a symbol or character string representing the mediator variable.
* `zmodels` is a list of fited `lm` or `glm` objects for post-treatment confounders of the mediator-outcome relationship. Users should set this argument to `NULL` if there are no post-treatment confounders.
* `interact` is a logical variable indicating whether baseline and post-treatment confounders should be balanced against the treatment-mediator interaction term(s).

The output returned by `rbwMed()` is a list containing the same elements as the output from `rbwATE()`. 

## Function `rbwPanel()` {short-title="rbwPanel" #rbwPanel}

This function produces residual balancing weights for estimating the marginal effects of time-varying treatments. It implements the steps described in Section \ref{rbw-panel} by taking a list of model objects for the conditional mean of each post-treatment confounder given past treatments and past confounders. Then it calls `eb2()` to find a set of weights, $rbw_{i}$, such that 1) residuals of the post-treatment confounders are orthogonal to future treatments and the observed past in the weighted sample, and 2) the relative entropy between $rbw_{i}$ and the base weights is minimized. Like the other functions, `rbwPanel()` ensures that the matrix of balancing constraints consists only of linearly independent columns. 

It is used as:

| `rbwPanel(treatment, xmodels, id, time, data, base_weights, max_iter = 200,`
|               `print_level = 1, tol = 1e-04, future = 1L)`

and takes the following arguments:

* `data`, `base_weights`, `max_iter`, `print_level`, and `tol` are defined as in `rbwATE()` and `rbwMed()`.
* `treatment` is a symbol or character string for the time-varying treatment.
* `xmodels` is a list of fitted `lm` or `glm` objects for time-varying confounders.
* `id` is a symbol or character string for the unit id variable.
* `time` is a symbol or character string for the time variable. 
* `future` is an integer indicating the number of future treatments in the balancing conditions. When `future > 0`, the residualized time-varying covariates are balanced not only with respect to current treatment $A_{t}$, but also with respect to future treatments $A_{t+1},...,A_{t+\texttt{future}}$. The default, `future = 1`, assumes away higher-ordered lagged effects of the covariates on the treatment. Users can leave out lagged effects entirely by setting `future` to zero.  

The output returned by `rbwPanel()` is essentially the same as those from `rbwATE()` and `rbwMed()`. The only difference is that the `weights` object, instead of a vector, is now a data frame with two columns: the id variable and the residual balancing weights (the column storing the weights is called `rbw`). 

# Examples {short-title="Examples" #examples}

We now illustrate the functions `rbwPanel()`, `rbwATE()`, and `rbwMed()` with data sets `advertisement`, `peace`, `campaign_long`, and `campaign_wide`, which are included in `rbw`. We expect users to rarely need to call `eb2()` manually since its primary use is to be called internally by the other functions. Hence, we see little gain in providing a separate example for it. 

## Point Treatment: Effects of Political Advertisements on Campaign Contributions {short-title="Point Treatment Example" #point-treatment-example}
  
@urbanDollarsSidewalkShould2014a studied the effects of televised political advertisements on campaign contributions. Presidential candidates do not tend to deliberately advertise in states where competition for electoral votes is tame. Yet, some areas of noncompetitive states have overlapping media markets with battleground states. Because these media market spillovers do not encompass other forms of campaigning (e.g., rallies, speeches, etc.), the authors can isolate the effect of television advertising by restricting their analyses to noncompetitive states. Their original method involved estimating the propensity score with logistic regression and then conducting propensity score matching. To do so, they dichotomized the political advertising variable to indicate whether zip codes received more than 1000 advertisements. 

Deeming this approach inadequate — in part because balancing against a dichotomous treatment does not ensure covariate balance on the underlying continuous variable — @fongCovariateBalancingPropensity2018 replicate the study using the CBPS method applied to a continuous treatment. Next, we examine how RBW fares compared with CBPS in this point treatment situation.^[Readers can find examples for IPW and its implementation using the `R` package `ipw` in @vanderwalIpwPackageInverse2011. @fongCovariateBalancingPropensity2018 and @zhouResidualBalancingMethod2020a use extensive simulation studies to demonstrate how their methods are more efficient and more accurate than IPW, so we do not draw similar comparisons here.]

Importantly, CBPS assumes that the treatment variable is normally distributed. To satisfy this assumption, @fongCovariateBalancingPropensity2018 search across Box-Cox transformations of the form 

\begin{equation}
\label{eq:12}
  a_{i}^{*} =
    \begin{cases}
      \frac{(a_{i}+1)^{\lambda}-1}{\lambda} & \text{if $\lambda\neq0$,}\\
      \log (a_{i}+1)  & \text{if $\lambda=0$}\\
    \end{cases}       
\end{equation}

to find the most appropriate transformation of the treatment. $a_{i}$ is the original treatment variable, the total number of political advertisements in a zip code, and $a_{i}^{*}$ is the transformed treatment. The authors add one to $a_{i}$ inside the Box-Cox transformations to avoid $\log (0)$ for zip codes that received no advertisements. They find the transformation with $\lambda=-0.16$ under which the marginal distribution of the treatment is closest to the standard normal. 

Let $A^{*}$ denote the Box-Cox transformed treatment. We also have a vector $X$ of baseline confounders that include the log population, population density, log median income, percent Hispanic, percent black, percent over age 65, percent college graduates, and a binary indicator of whether it is possible to commute to the zip code from a competitive state. Finally, $Y$ represents the outcome, campaign contributions in thousands of dollars. 

@fongCovariateBalancingPropensity2018 propose an MSM that includes the transformed treatment variable, its square, and state dummies $U$ to account for state fixed effects:

\begin{equation}
\label{eq:13}
\mathbb{E}[Y(a^{*})|U]=\theta_{0}+\theta_{1}a^{*} +\theta_{2}(a^{*})^{2}+\theta_{3}^{T}U.
\end{equation}

The data set `advertisement` contains the variables necessary for the analyses:

* `zip` denotes zip code.
* `TotAds` is the total number of political advertisements aired in the zip code.
* `treat` is the Box-Cox transformed `TotAds`. 
* `TotalPop` is the population size. 
* `log_TotalPop` is the log population size
* `Inc` is the median household income.
* `log_Inc` is the log median household income.
* `PercentOver65` is the percent of the population over 65.
* `PercentHispanic` is the percent of the population Hispanic.
* `PercentBlack` is the percent of the population black.
* `per_collegegrads` is the percent college graduates.
* `density` is the population density (people per square mile).
* `CanCommute` is a dummy variable indicating whether it is possible to commute to the zip code from a competitive state.
* `Cont` measures campaign contributions (in thousands of dollars).
* `StFIPS` is the FIPS code of the state.

We start by loading the necessary packages:

```{r include = FALSE}
library("kableExtra")
```

```{r message = FALSE, warning = FALSE}
library("rbw")
library("CBPS")
```

`rbw::rbwATE()` will construct the residual balancing weights by following the steps described in Section \ref{rbw-treatment}. It first computes the baseline residuals $\hat{\delta}(x_{ij})=x_{ij}-\text{avg}({x}_{j})$ and then finds a set of weights such that, in the weighted sample, $\hat{\delta}(x_{ij})$ are orthogonal to the treatment, and the relative entropy between the residual balancing weights and a set of base weights is minimized. Since `advertisement` does not include sampling weights, `rbw::rbwATE()` will set a vector of ones with length equal to the sample size as the base weights. To facilitate comparisons of computation time, we also call `Sys.time()` before and after running the functions that produce the weights in each package. 

```{r message = FALSE}
rbwATE_start <- Sys.time()
rbwATE_fit <- rbwATE(treat, baseline_x = c(log_TotalPop, PercentOver65,  
    log_Inc, PercentHispanic, PercentBlack, density,
    per_collegegrads, CanCommute), data = advertisement)
rbwATE_end <- Sys.time()
rbwATE_time <- rbwATE_end - rbwATE_start
```

Next, we attach the $rbw_{i}$ weights to the data:

```{r}
advertisement$rbwATE_weights <- rbwATE_fit$weights
```

Following most applications of MSMs, we compute standard errors using the robust ("sandwich") variance estimator. This can be implemented with the function `survey::svydesign()`, which allows us to specify a complex survey design and estimate standard errors consistent with this specification.^[@zhouResidualBalancingMethod2020a conduct various simulation studies to assess the performance of the robust variance estimator across different methods. They find that the estimator tends to overestimate the true sampling variance for residual balancing across nearly all scenarios, making it consistently conservative for RBW. By contrast, the estimator sometimes overestimates and other times underestimates the true sampling variance for other weighting methods, including CBPS.]

```{r message = FALSE}
library("survey")
rbwATE_design <- svydesign(ids = ~1, weights = ~rbwATE_weights, 
    data = advertisement)
```

We then use the residual balancing weights to fit the MSM defined in Equation \ref{eq:13}:

```{r}
rbwATE_msm <- svyglm(Cont ~ treat + I(treat^2) + factor(StFIPS), 
    design = rbwATE_design)
```

Since we have transformed our treatment variable, we need to make necessary adjustments to compute the treatment effect. Let us first use a scalar object to store the parameter estimated from the Box-Cox transformation:

```{r}
lambda <- -0.16
```

Like @urbanDollarsSidewalkShould2014a, @fongCovariateBalancingPropensity2018 are interested in the effect of going from zero to 1,000 political advertisements on compaign contributions. Hence, we create a `dose` variable to account for this. If $A^{*}$ is the transformed treatment and $A$ is the treatment variable on its original scale, $A^{*}=[(A+1)^{\lambda}-1]/\lambda$. Our dose is thus given by $dose=[(1000+1)^{\lambda}-1]/\lambda$:

```{r}
dose <- ((1000 + 1)^lambda - 1)/lambda
```

To find the estimate  $\hat{\tau}_{rbw}$ of the average treatment effect, we must consider both the linear and squared treatment terms in the MSM. We also multiply the result by 1,000 since the outcome variable is measured in thousands of dollars: 

```{r}
rbwATE_tau <- 1000 * (coef(rbwATE_msm)[2] * dose + coef(rbwATE_msm)[3] * dose^2)
```

We can use the basic properties of the variance operator to derive the formula for $\text{Var}[\hat{\tau}_{rbw}]$:

\begin{equation}
\label{eq:14}
\text{Var}[\hat{\tau}_{rbw}]=dose^{2}\text{Var}[\hat{\theta}_1]+dose^{4}\text{Var}[\hat{\theta}_2] + 2*dose^{3}\text{Cov}[\hat{\theta}_1, \hat{\theta}_2].
\end{equation}

The function `stats::vcov()` applied to the object `rbwATE_msm` yields estimates of $\text{Var}[\hat{\theta}_1]$, $\text{Var}[\hat{\theta}_2]$, and $\text{Cov}[\hat{\theta}_1, \hat{\theta}_2]$. Again, we multiply the result by 1,000 given the scale of the outcome variable:


```{r}
rbwATE_vcov <- stats::vcov(rbwATE_msm)
rbwATE_se <- 1000 * sqrt(dose^2 * rbwATE_vcov[2, 2] + 
    dose^4 * rbwATE_vcov[3, 3] + 
    2 * dose^3 * rbwATE_vcov[2, 3])
```

We now repeat the steps above using the `CBPS()` and `npCBPS()` functions from the `CBPS` package to estimate weights using both the parametric and nonparametric CBPS approaches. Recall from Section \ref{intro} that the former is similar to IPW in that it requires explicit models for the conditional distributions of the treatment. However, it improves the IPW method by considering a set of balancing conditions during the propensity score estimation, thereby reducing sensitivity to model misspecification. By contrast, the nonparametric CBPS (npCBPS) does not require direct estimation of the propensity score; instead, it finds weights that maximize the empirical likelihood while meeting a set of balancing constraints. As such, like RBW, it avoids the need to specify a propensity score model. 

@fongCovariateBalancingPropensity2018 propose a treatment model that includes all baseline confounders $X$ defined above in addition to the square terms of all continuous covariates. We define the formula accordingly:

```{r}
CBPS_pscore_form <- treat ~ log(TotalPop) + PercentOver65 + 
    log(Inc + 1) + PercentHispanic + PercentBlack + 
    density + per_collegegrads +CanCommute + I(log(TotalPop)^2) + 
    I(PercentOver65^2) + I(log(Inc + 1)^2) + I(PercentHispanic^2) + 
    I(PercentBlack^2) + I(density^2) + I(per_collegegrads^2)
```

We first construct the CBPS weights:

```{r message = FALSE, warning = FALSE, cache=TRUE}
CBPS_start <- Sys.time()
CBPS_fit <- CBPS(CBPS_pscore_form, data = advertisement, 
    twostep = TRUE, method = "exact")
CBPS_end <- Sys.time()
CBPS_time <- CBPS_end - CBPS_start
```

Next, we compute the npCBPS weights: 

```{r include = FALSE, cache=TRUE}
npCBPS_start <- Sys.time()
npCBPS_fit <- npCBPS(CBPS_pscore_form, data = advertisement, 
    corprior = 0.1/nrow(advertisement))
npCBPS_end <- Sys.time()
npCBPS_time <- npCBPS_end - npCBPS_start
```

```{r eval = FALSE, cache=TRUE}
npCBPS_start <- Sys.time()
npCBPS_fit <- npCBPS(CBPS_pscore.form, data = advertisement, 
    corprior = 0.1/nrow(advertisement))
npCBPS_end <- Sys.time()
npCBPS_time <- npCBPS_end - npCBPS_start
```

We attach them to the data:

```{r}
advertisement$CBPS_weights <- CBPS_fit$weights
advertisement$npCBPS_weights <- npCBPS_fit$weights
```

Following the steps above, we estimate $\hat{\tau}_{CBPS}$:

```{r message = FALSE}
CBPS_design <- svydesign(ids = ~1, weights = ~ CBPS_weights, 
    data = advertisement)
CBPS_msm <- svyglm(Cont ~ treat + I(treat^2) + factor(StFIPS), 
    design = CBPS_design)
CBPS_tau <- 1000 * (coef(CBPS_msm)[2] * dose + coef(CBPS_msm)[3] * dose^2)
```

Similarly for $\hat{\tau}_{npCBPS}$:

```{r message = FALSE}
npCBPS_design <- svydesign(ids = ~1, weights = ~npCBPS_weights, 
    data = advertisement)
npCBPS_msm <- svyglm(Cont ~ treat + I(treat^2) + factor(StFIPS), 
    design = npCBPS_design)
npCBPS_tau <- 1000 * (coef(npCBPS_msm)[2] * dose + coef(npCBPS_msm)[3] * dose^2)
```

Then we compute the CBPS standard error:

```{r message = FALSE}
CBPS_vcov <- stats::vcov(CBPS_msm)
CBPS_se <- 1000 * sqrt(dose^2 * CBPS_vcov[2, 2] + 
    dose^4 * CBPS_vcov[3, 3] + 
    2 * dose^3 * CBPS_vcov[2, 3])
```

As well as its npCBPS counterpart:

```{r}
npCBPS_vcov <- stats::vcov(npCBPS_msm)
npCBPS_se <- 1000 * sqrt(dose^2 * npCBPS_vcov[2, 2] + 
    dose^4 * npCBPS_vcov[3, 3] + 
    2 * dose^3 * npCBPS_vcov[2, 3])
```

Table \ref{tab:point-treatment-comparison} summarizes the findings. The methods that do not require a propensity score model, RBW and npCBPS, yield similar point estimates and standard errors. By contrast, the estimate associated with CBPS is somewhat smaller. Finally, the last column shows that different loss functions for the optimization problem can lead to stark differences in computation time. While RBW's relative entropy metric leads to a convex optimization problem that Newton's method can solve in less than one second, npCBPS's algorithm takes several minutes to run.

```{r echo = FALSE}
point_treatment_comparsion_df <- data.frame(c("RBW", "CBPS", "npCBPS"),
                                   c(round(rbwATE_tau, 0), round(CBPS_tau, 0), round(npCBPS_tau, 0)),
                                   c(round(rbwATE_se, 0), round(CBPS_se, 0), round(npCBPS_se, 0)),
                                   c(round(as.numeric(rbwATE_time, units="secs"), 2), round(as.numeric(CBPS_time, units="secs"), 2), round(as.numeric(npCBPS_time, units="secs"), 2)))
point_treatment_comparsion_table <- knitr::kable(point_treatment_comparsion_df, 
                                                 booktabs = T,
                                                 caption = "Comparison of RBW, CBPS, and npCBPS for a Point Treatment Situation",
                                                 linesep = "",
                                                 align = "l",
                                                 format = "latex",
                                                 label = "point-treatment-comparison",
                                                 col.names = linebreak(c("Method",
                                                                         "Estimate",
                                                                         "Standard Error",
                                                                         "Computation Time (in Seconds)")),
                                                 escape = FALSE,
                                                 position = "h"
)
add_footnote(point_treatment_comparsion_table, c("Computation time may differ depending on system setup.", "System setup used to generate the results: MacBook Pro (15-inch, 2018), 2.2 GHz 6-Core Intel Core i7, 16GB RAM."),
             notation = "none")
```

We next illustrate the use of `rbwMed()` and `rbwPanel()`. In contrast to the point treatment example, the following sections do not draw comparisons with other existing methods. Interested readers can refer to @zhouResidualBalancingMethod2020a for such comparisons.

## Causal Mediation Analysis: The Controlled Direct Effect of Shared Democracy on Public Support for War {short-title="Causal Mediation Example" #causal-mediation-example}

A stylized fact in political science is that democracies do not engage in war with one another. To assess the role of public opinion in keeping the peace, @tomzPublicOpinionDemocratic2013a designed survey experiments that presented participants with a situation where a country was developing nuclear weapons. When describing the situation, the authors randomly and independently changed three characteristics of the country: its political regime (whether it was a democracy), alliance status (whether it had signed a military alliance with the United States), and economic ties (whether it had high levels of trade with the U.S.). The outcome of interest was the respondent's support for military action on a five-point scale ranging from "oppose strongly" to "favor strongly." The authors found that respondents were considerably less supportive of military action against democracies than otherwise identical autocratic regimes. 

They then went on to investigate the causal mechanisms through which shared democracy reduces public enthusiasm for war. In particular, @tomzPublicOpinionDemocratic2013a measured individuals' beliefs about the level of threat posed by the potential adversary, the cost of the intervention, and the likelihood of success. They also collected data on people's moral concerns about using military force. Their methodological framework focuses on estimating the natural direct and natural indirect effects [@imaiUnpackingBlackBox2011; @imaiIdentificationInferenceSensitivity2010], whose identification assumptions require that no post-treatment confounding of the mediator-outcome relationship exists. As such, the authors examined the role of each mediator separately by assuming they operate independently of one another. Yet, as discussed in @zhouResidualBalancingMethod2020a, beliefs about the threat, cost, and likelihood of success may affect an individual's perceptions of morality while also influencing support for war directly. By treating these variables as post-treatment confounders, @zhouResidualBalancingMethod2020a analyzed the mediating role of morality using controlled direct effects. 

Let $A$ denote the treatment, whether the country developing nuclear weapons was presented as a democracy, $M$ the mediator, a dummy variable indicating whether the participant deemed the military action morally wrong, and $Y$ the outcome, the respondent's support for war on a five-point scale. We also have a set of baseline confounders ($X$) including dummies for the other two randomized treatments (alliance status and economic ties) in addition to several demographic and attitudinal controls.^[For example, attitudinal controls include respondents' attitudes toward ethnocentrism with a series of questions about their opinions on immigration, affirmative action, and gay marriage.] Finally, $Z$ is a vector of post-treatment confounders comprising measures of beliefs about the threat, cost, and likelihood of success. 

Our MSM is thus defined as:

\begin{equation}
\label{eq:15}
\mathbb{E}[Y(a, m)]=\alpha_{0}+\alpha_{1}a +\alpha_{2}m+\alpha_{3}am.
\end{equation}

We can alternatively include the baseline confounders in the MSM instead of balancing them across the treatment and the mediator with baseline residuals:

\begin{equation}
\label{eq:16}
\mathbb{E}[Y(a, m)|X]=\alpha_{0}+\alpha_{1}a +\alpha_{2}m+\alpha_{3}am + \alpha_{4}^{T}X.
\end{equation}

The `peace` data set includes the variables we will use in the analyses:

* `democ` is a dummy variable indicating whether the country was a democracy.
* `threatc` is the number of adverse events respondents considered probable if the US did not engage in war.
* `cost` is the number of negative consequences anticipated if the US engaged in war.
* `successc` indicates whether the respondent thought the operation would succeed:
    * 0: less than 50-50 chance of working even in the short run
    * 1: efficacious only in the short run
    * 2: successful both in the short and long run
* `immoral` indicates whether respondents thought it would be morally wrong to strike the country.
* `ally` indicates whether the country had signed a military alliance with the US.
* `trade` indicates whether the country had high levels of trade with the US.
* `h1` is an index measuring respondent's attitude toward militarism.
* `i1` is an index measuring respondent's attitude toward internationalism.
* `p1` is an index measuring respondent's identification with the Republican party.
* `e1` is an index measuring respondent's attitude toward ethnocentrism.
* `r1` is an index measuring respondent's attitude toward religiosity.
* `male` indicates whether the respondent is male.
* `white` indicates whether the respondent is white.
* `age` is the respondent's age.
* `ed4` is the respondent's education with categories ranging from high school or less to postgraduate degree.
* `strike` is a measure of support for war on a five-point scale.

We first consider the approach where the baseline confounders are balanced across the treatment and the mediator using the baseline residuals computed from centering each covariate around its sample mean. 

As explained in Section \ref{rbw-mediation}, RBW in causal mediation analysis requires models for the conditional means of each post-treatment confounder $Z_{j}$ given the treatment $a_{i}$ and the baseline confounders $x_{i}$: $\hat{\mathbb{E}}[z_{ij}|a_{i},x_{i}]$. Hence, we assume that `threatc`, `cost`, and `successc` are measured on a continuous scale and fit linear models for each: 

```{r message = FALSE}
z1 <- lm(threatc ~ ally + trade + h1 + i1 + p1 + e1 + r1 + 
    male + white + age + ed4 + democ, data = peace)
z2 <- lm(cost ~ ally + trade + h1 + i1 + p1 + e1 + r1 + 
    male + white + age + ed4 + democ, data = peace)
z3 <- lm(successc ~ ally + trade + h1 + i1 + p1 + e1 + r1 + 
    male + white + age + ed4 + democ, data = peace)
```

We then store the three model objects together in a list to be passed later to the `zmodels` argument in `rbwMed()`: 

```{r message = FALSE}
zmodels <- list(z1, z2, z3)
```

To construct the residual balancing weights, `rbwMed()` will 1) compute the baseline residuals $\hat{\delta}(x_{ij})=x_{ij}-\text{avg}({x}_{j})$ and the post-treatment residuals $\hat{\delta}(z_{ij})=z_{ij}-\mathbb{E}[z_{ij}|a_{i},x_{i}]$ and 2) find a set of weights such that a) in the weighted sample, the baseline and post-treatment residuals meet the orthogonality requirements explained in Section \ref{rbw-mediation}, and b) the relative entropy between the residual balancing weights and a set of base weights is minimized. The function will use a vector of ones as the base weights since `peace` does not include sampling weights. We also pass the name of our mediator to the `mediator` argument:

```{r message = FALSE}
rbwMed_fit <- rbwMed(treatment = democ, mediator = immoral, 
    zmodels = zmodels, baseline_x = c(ally, trade, h1, i1, 
    p1, e1, r1, male, white, age, ed4), data = peace)
```

Next, we attach the weights to `peace`:

```{r}
peace$rbwMed_weights <- rbwMed_fit$weights
```

We use `survey::svydesign()` to estimate robust standard errors:

```{r message = FALSE}
rbwMed_design <- svydesign(ids = ~1, weights = ~rbwMed_weights, 
    data = peace)
```

Finally, we use the residual balancing weights to fit the MSM from Equation \ref{eq:15}:

```{r message = FALSE}
rbwMed_msm <- svyglm(strike ~ democ * immoral, 
    design = rbwMed_design)
```

Steps are similar for the case where the baseline confounders are not balanced against the treatment and the mediator but instead adjusted in the MSM, as defined in Equation \ref{eq:16}. The models for the conditional means of the post-treatment confounders are the same as before:

```{r}
rbwMed2_fit <- rbwMed(treatment = democ, mediator = immoral, 
    zmodels = zmodels, data = peace)
peace$rbwMed2_weights <- rbwMed2_fit$weights
rbwMed2_design <- svydesign(ids = ~ 1, weights = ~ rbwMed2_weights, 
    data = peace)
rbwMed2_msm <- svyglm(strike ~ ally + trade + h1 + i1 + p1 + 
    e1 + r1 + male + white + age + ed4 + democ * immoral, 
    design = rbwMed2_design)
```

We summarize the results in Table \ref{mediation-comparison}. The estimated CDE if respondents lacked any moral qualms about military intervention, i.e., $\widehat{\text{CDE}}(m=0)=\hat{\mathbb{E}}[Y(1,0)-Y(0,0)]=\hat{\alpha}_{1}$, is $-0.32$ under the first approach and $-0.36$ under the second. Both estimates are statistically significant at the level of 0.01. The estimated CDE if respondents had moral qualms about military intervention, i.e., $\widehat{\text{CDE}}(m=1)=\hat{\mathbb{E}}[Y(1,1)-Y(0,1)]=\hat{\alpha}_{1} + \hat{\alpha}_{3}$, is $-0.36$ under the first approach but only $-0.22$ under the second.

```{r message = FALSE, results = 'asis', echo = FALSE}
library(stargazer)
stargazer(rbwMed_msm, rbwMed2_msm,
          header = FALSE,
          column.labels = c("\\shortstack{Baseline Confounders \\\\ Balanced}", 
                            "\\shortstack{Baseline Confounders \\\\ Adjusted in the MSM}"),
          covariate.labels = c("Shared democracy", "Moral concerns", "Shared democracy * Moral concerns"),
          title="MSM Results for the Controlled Direct Effects of Shared Democracy on Public Support for War",
          keep = c("democ", "immoral", "democ:immoral"),
          dep.var.caption = "",
          omit.stat = c("aic","ll","n"),
          dep.var.labels.include = FALSE,
          model.numbers = FALSE,
          table.placement = "h",
          label = "mediation-comparison",
          notes.align = "l",
          notes.label = "",
          notes = c("Robust standard erros in parentheses."))
```

## Time-Varying Treatment: The Cumulative Effect of Negative Advertising on Vote Shares {short-title="Time-Varying Example" #time-varying-example}

We conclude this section with an example of RBW applied to a context involving time-varying treatments and confounders. Political scientists have shown interest in examining the cumulative effect of negative campaign advertising on election outcomes [@lauEffectsNegativePolitical2007; @blackwellFrameworkDynamicCausal2013; @imaiRobustEstimationInverse2015]. This is an intricate process because while polling results affect current campaign strategies, they are also constantly shifting, as they respond both to previous results and candidates' use of negative advertising in the past. For their ability to accommodate dynamic causal relationships — particularly since they allow past treatments to affect current outcomes (i.e., "carryover effects") and past outcomes to influence current treatment (i.e., "feedback effects") [@imaiWhenShouldWe2019] — MSMs are suitable for this research question.

Let $A_{t}$ represent our continuous treatment, the proportion of campaign advertisements mentioning the adversary in each campaign week, $L_{t}$ our time-varying confounders, the Democratic share and the share of undecided voters in the polls, and $Y$ the outcome, the Democratic share of the two-party vote. Additionally, we have a set of baseline confounders $X$ including total campaign length, election year, and whether the election is senatorial or gubernatorial. 

@zhouResidualBalancingMethod2020a define an MSM as follows:

\begin{equation}
\label{eq:17}
\mathbb{E}[Y(\bar{a})|X]=\beta_{0}+\beta_{1}\text{avg}(\bar{a})+\beta_{2}V+\beta_{3}\text{avg}(\bar{a})V+\beta_{4}^{T}X,
\end{equation}

where $V$ is an indicator of incumbency status used to construct interactions that allow the effect to differ between incumbents and nonincumbents, and $\text{avg}(\bar{a})$ is the average proportion of advertisements that were negative over the final five weeks of the campaign multiplied by ten (we multiply by ten following @zhouResidualBalancingMethod2020a so that regression coefficients can be interpreted as the effect of a ten-percentage point increase in negative advertising). 

`rbw` contains two data sets associated with this problem: `campaign_long` and `campaign_wide`. They represent, respectively, the long-format and wide-format data on negative campaign advertising. 

The following variables are included in `campaign_long`:

* `neg.dem` is the propotion of advertisements that were negative in a campaign-week. 
* `dem.polls` is the Democratic share in the polls.
* `undother` is the share of undecided voters in the polls.
* `neg.dem.l1` is the proportion of advertisements that were negative in the previous campaign-week.
* `dem.polls.l1` is the Democratic share in the polls in the previous campaign-week.
* `undother.l1` is the share of undecided voters in the polls in the previous campaign-week. 
* `camp.length` is the length of the candidate's campaign (in weeks).
* `deminc` indicates whether the candidate was an incumbent.
* `base.poll` is the Democratic share in the baseline polls. 
* `base.und` is the share of undecided voters in the baseline polls.
* `office` is the type of office in contest:
    * 0: governor
    * 1: senator
* `week` indicates week in the campaign (in the final five weeks preceding the election). 
* `year` is the election year.
* `state` is the election state.
* `id` is the candidate id. 
* `demName` is the name of the Democratic candidate.
* `demprcnt` is the Democratic share of the two-party vote in the election.

In addition, `campaign_wide` contains the following variables: 

* `ave_neg` is the average proportion of advertisements that were negative over the final five weeks of the campaign multiplied by ten.
* `neg.dem_1` is the propotion of advertisements that were negative in week 1 polls. 
* `neg.dem_2` is the propotion of advertisements that were negative in week 2 polls. 
* `neg.dem_3` is the propotion of advertisements that were negative in week 3 polls. 
* `neg.dem_4` is the propotion of advertisements that were negative in week 4 polls. 
* `neg.dem_5` is the propotion of advertisements that were negative in week 5 polls.
* `dem.polls_1` is the Democratic share in week 1 polls.
* `dem.polls_2` is the Democratic share in week 2 polls.
* `dem.polls_3` is the Democratic share in week 3 polls.
* `dem.polls_4` is the Democratic share in week 4 polls.
* `dem.polls_5` is the Democratic share in week 5 polls.
* `undother_1` is the share of undecided voters in week 1 polls.
* `undother_2` is the share of undecided voters in week 2 polls.
* `undother_3` is the share of undecided voters in week 3 polls.
* `undother_4` is the share of undecided voters in week 4 polls.
* `undother_5` is the share of undecided voters in week 5 polls.
* `camp.length`, `deminc`, `base.poll`, `base.und`, `office`, `year`, `state`, `id`, `demName`, and `demprcnt` are defined as in `campaign_long`.

Recall from Section \ref{rbw-panel} that RBW requires us to fit a model for the conditional mean of each covariate at each time point given the observed past. We thus estimate regression models of our time-varying confounders $L_{t}$ ($t\ge2$) on lagged treatment and lagged confounders. We also interact each regressor with the week dummies, thus allowing the coefficients to change over time in a flexible manner:

```{r}
x1 <- lm(dem.polls ~ (neg.dem.l1 + dem.polls.l1 + undother.l1) * factor(week), 
    data = campaign_long)
x2 <- lm(undother ~ (neg.dem.l1 + dem.polls.l1 + undother.l1) * factor(week), 
    data = campaign_long)
```

We then create a list with the model objects to be passed later to the `xmodels` argument in `rbwPanel()`: 

```{r message = FALSE}
xmodels <- list(x1, x2)
```

To construct the residual balancing weights, `rbwPanel()` first extracts the residual terms $\hat{\delta}(L_{t})$ from the models above. Note that for each covariate in $L_{1}$ (the first time period), the residuals are computed as deviations from the sample mean. Then the function finds a set of weights, such that, in the weighted sample, the residuals are orthogonal to current and future treatments as well as the regressors of $L_{jt}$, and the relative entropy between the residual balancing weights and the base weights is minimized. Note that we set the `future` argument to zero to replicate the results from @zhouResidualBalancingMethod2020a since the authors balance the residualized time-varying confounders only with respect to the current treatment, thus assuming away lagged effects of the covariates on the treatment.^[The negative advertising data set spans five weeks, so users interested in considering lagged effects of the time-varying covariates on the treatment may set `future > 0`, up to `future = 4`.] Since our data do not include sampling weights, a vector of ones is used as the base weights. Additionally, we need to pass arguments indicating the unit id and the time variables due to the longitudinal structure of our data set. 

```{r message = FALSE}
rbwPanel_fit <- rbwPanel(treatment = neg.dem, xmodels = xmodels, 
    id = id, time = week, data = campaign_long, future = 0)
```

We now attach the weights to `campaign_wide` using the pipe operator and the `left_join()` function from the package `dplyr` (this merging is permitted because the `weights` object returned by `rbwPanel()` is a data frame containing the id variable and the residual balancing weights):

```{r include = FALSE}
library("dplyr")
campaign_wide <- campaign_wide %>%
    left_join(rbwPanel_fit$weights, by = "id")
```

```{r eval = FALSE}
library("dplyr")
campaign_wide <- campaign_wide %>%
    left_join(rbwPanel_fit$weights, by = "id")
```

We use the functions from `dplyr` to rename the weights so that our variable's name is consistent with the previous examples: 

```{r}
campaign_wide <- campaign_wide %>%
    rename(rbwPanel_weights = rbw)
```

Again, we use `survey::svydesign()` to compute robust standard errors:

```{r}
rbwPanel_design <- svydesign(ids = ~1, weights = ~rbwPanel_weights, 
    data = campaign_wide)
```

Finally, we use the residual balancing weights to fit the MSM from Equation \ref{eq:17}:

```{r message = FALSE}
rbwPanel_msm <- svyglm(demprcnt ~ ave_neg * deminc + camp.length + 
    factor(year) + office, design = rbwPanel_design)
```

We report the model results in Table \ref{time-varying-model}. The estimate for nonincumbents is $0.49$ and for incumbents is $0.49-1.48=-0.99$. The effect of negative advertisement for nonincumbents is positive though not statistically significant. However, the interaction term is significant at the level of 0.01, and incumbents see a sizeable negative effect from negative advertising: a ten percentage point increase in negative advertising reduces a candidate's vote share by about one percentage point, on average. 

```{r message = FALSE, results = 'asis', echo = FALSE}
stargazer(rbwPanel_msm,
          header = FALSE,
          covariate.labels = c("Average proportion", "Incumbency", "Average proportion * Incumbency"),
          title="MSM Results for the Cumulative Effect of Negative Advertising on Vote Shares",
          keep = c("ave_neg", "deminc", "ave_neg:deminc"),
          dep.var.caption = "",
          omit.stat = c("aic","ll","n"),
          dep.var.labels.include = FALSE,
          model.numbers = FALSE,
          table.placement = "h",
          label = "time-varying-model",
          notes.align = "l",
          notes.label = "",
          notes = c("Robust standard errors in parentheses."))
```

# Conclusion {short-title="Conclusion" #conclusion}

Compared to other methods of constructing weights for MSMs, RBW has several advantages. In particular, it does not require modeling the conditional distributions of exposures and is thus easy to use with continuous treatments. Previous simulation studies suggest that it is often more efficient and more robust to model misspecification than alternative weighting strategies [@zhouResidualBalancingMethod2020a]. RBW is also favorable from a computational perspective. Its procedure for finding weights involves a convex optimization problem, allowing RBW to locate a solution substantially faster than alternative methods whose optimization relies on nonconvex loss functions — such as the recently proposed nonparametric version of CBPS, which uses the empirical likelihood [@fongCovariateBalancingPropensity2018]. Table \ref{tab:method-comparison} sums up these comparisons. 

```{r echo = FALSE}
method_comparsion_df <- data.frame(c("IPW", "CBPS", "npCBPS", "RBW"),
                                   c("Required", "Required", "Not Required", "Not Required"),
                                   c("Absent", "Present", "Present", "Present"),
                                   c("Yes", "Yes", "No", "Yes"),
                                   c("ipw", "CBPS", "CBPS", "rbw"))
knitr::kable(method_comparsion_df, 
             booktabs = T,
             caption = "Comparison of Methods and Software Implementation",
             linesep = "",
             format = "latex",
             label = "method-comparison",
             col.names = linebreak(c("Method",
                  "Models for Conditional\nDistributions of Exposures",
                  "Balancing\nConstraints",
                  "Implemented for\nTime-varying Treatments?",
                  "R Package")),
             escape = FALSE,
             position = "h"
)
```

After explaining the underlying logic of RBW, we have described its implementation in the `R` package `rbw`. With examples from several data sets, we have demonstrated the use of `rbw` in three distinct contexts: effect estimation for point treatments, causal mediation analysis, and effect estimation for time-varying treatments with time-varying confounders.

Nonetheless, RBW is not without limitations. In particular, it depends on models for the conditional means of post-treatment confounders. When these models are incorrectly specified, the pseudo-population generated by residual balancing weights will fail to mimic the original unweighted population, and our estimates will be biased. Even when these models are correctly specified, RBW may also yield biased estimates when we have insufficient balancing conditions. Adding more functions such as cross-products and high-order terms to the set $G(L_{t})=\{g_{1}(L_{t}),...,g_{J_{t}}(L_{t})\}$, thereby increasing the number of balancing constraints, may help — though at the risk of making exact balance infeasible. A possible extension to RBW would be to allow for approximate balance with a penalty for the remaining imbalance in the optimization problem [@fongCovariateBalancingPropensity2018].

Despite these limitations, RBW will be useful to many social scientists interested in using marginal structural models to study causality in dynamic settings. We will continue to update the package with functions that expand RBW's range of applicability (e.g., to contexts involving repeated outcome measures and to cases where, as discussed above, exact balance is infeasible and approximate balance must be pursued).

\newpage

# References
